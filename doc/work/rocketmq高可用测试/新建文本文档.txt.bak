0）升级rocketmq-client。下周二问情况，client都升级了就升级server。
   rocketmq主备模式，主备切换测试
   主挂了，producer发到另一个主上面。consumer从salve消费。slave无法自己提升为主。需要人主动提升主、或者启动主
   主挂了，slave升级为主。再启动一个salve从当前的主，获取所有的消息吗？还是未消费的消息
   
启动是先启动nameservserv  再起动broker  
cd /usr/local/rocketmq/bin
nohup sh /usr/local/rocketmq/bin/mqnamesrv &
nohup sh /usr/local/rocketmq/bin/mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-a.properties >/dev/null 2>&1 &

关闭namesrv服务：sh /usr/local/rocketmq/bin/mqshutdown namesrv
关闭broker服务 ：sh /usr/local/rocketmq/bin/mqshutdown broker

异步master-slave ha情况：
测试1）启动master。停止slave。
    发消息，消息都消费完毕，启动slave，salve会同步master所有消息，包括已读未读消费
测试2）master启动，slave启动，挂掉master
    master未消费的消息仍会得到消费
    仍然可以从另一个master发送出去
测试3）所有master都挂掉
     org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, haTestTopic
测试4）所有master都起来
     可收发消息
测试5）主挂掉了，从消费，会增加从的offset。当主启动起来会重复消费
       自己考虑幂等  
测试6）正常退出，删除consumequeue后，consumeOffset.json中1:30,consumer从老的offset(30)消费，会产生一条OFFSET_MOVED_EVENT消息。再发消息，consumer会在consumeOffset.json新建队列消费进度1:0
       如果之后出现不正常退出，再启动会从commitLog恢复consumequeue,这时consumeOffset.json仍为1:0会重复消费
       总之意思就是：删除consumequeue，删除完了，异常退出后，再重启会根据commitLog将consumequeue恢复到删除之前的状态,而consumeOffset还是从0开始消费
测试7）原来rocketmq升级，升级后store目录不变consumequeue目录也不变，结果配置变了consumequeue下的文件大小变了，导致老版本的该目录下的文件，在新的版本中无法加载到内存
测试8）rocketmq预发环境 主加备后重复消费问题排查：
     原rocketmq升级，升级后store/consumequeue目录没变，但配置变了，consumequeue下的文件大小变了，导致老版本的该目录下的文件，在新的版本中无法加载到内存
     线上准备新搭建rocketmq双主备模型，不使用老的store目录
测试9）rocketmq删除consumequeue文件夹以达到清空消费队列目的方法有问题：
     删除consumequeue之后，如果broker出现异常退出，再重启broker会根据commitLog将consumequeue恢复到删除之前的状态，会导致重复消费  
       
同步复制情况：
   private int haSlaveFallbehindMax = 1024 * 1024 * 256;
   slave落后超过512M则不再同步复制。 
   Message.properties中"WAIT"属性可以指定本次是否需要等待同步到salve。同步模式，默认都等待同步
   同步复制如果同步到slave超时，则返回给producer的result的status为SLAVE_TIMEOUT